#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.8.3 on Thu Aug 09 23:03:17 2018
#

import wx
import wx.grid
import sys
import pyembroidery
from pyembroidery.CsvWriter import get_common_name_dictionary
from pyembroidery.CsvReader import get_command_dictionary

USE_BUFFERED_DC = True


class EmbroiderDisplay:
    def __init__(self):
        self.emb_pattern = None
        self.extends = None
        self.name = None
        self.draw_data = None
        self.max_stitch = 0
        self.current_stitch = -1

    def load(self, filename):
        self.emb_pattern = pyembroidery.read(filename)
        self.extends = self.emb_pattern.extends()
        self.rebuild_draw_data()
        self.name = filename

    def get_copy(self):
        copy = EmbroiderDisplay()
        copy.emb_pattern = self.emb_pattern
        copy.extends = self.emb_pattern.extends()
        copy.rebuild_draw_data()
        copy.name = self.name
        return copy

    def rebuild_draw_data(self):
        self.draw_data = []
        self.max_stitch = 0
        for color in self.emb_pattern.get_as_stitchblock():
            lines = []
            last_x = None
            last_y = None
            for stitch in color[0]:
                current_x = stitch[0] - self.extends[0]
                current_y = stitch[1] - self.extends[1]
                if last_x is not None:
                    lines.append([last_x, last_y, current_x, current_y])
                    self.max_stitch += 1
                last_x = current_x
                last_y = current_y
            thread = color[1]
            self.draw_data.append(((thread.get_red(), thread.get_green(), thread.get_blue()), lines))

    def scale_draw_data(self, width, height):
        self.rebuild_draw_data()
        self.draw_data = self.get_scaled_draw_data(self.draw_data, width, height)

    def get_scaled_draw_data(self, data, width, height):
        new_data = []
        embroidery_width = self.extends[2] - self.extends[0]
        embroidery_height = self.extends[3] - self.extends[1]
        scale_x = float(width) / embroidery_width
        scale_y = float(height) / embroidery_height
        scale = min(scale_x, scale_y)
        for element in data:
            scaled_lines = []
            unscaled_lines = element[1]
            for e in unscaled_lines:
                scaled_lines.append([scale * e[0], scale * e[1], scale * e[2], scale * e[3]])
            new_data.append((element[0], scaled_lines))
        return new_data

    def decrement_stitch(self):
        self.current_stitch -= 1
        if self.current_stitch < 0:
            self.current_stitch = self.max_stitch

    def increment_stitch(self):
        self.current_stitch += 1
        if self.current_stitch > self.max_stitch:
            self.current_stitch = 0


class EmbroideryView(wx.Panel):
    def __init__(self, *args, **kwds):
        self.design = None

        self._Buffer = None

        # begin wxGlade: EmbroideryView.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Panel.__init__(self, *args, **kwds)

        # end wxGlade
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnErase)
        # wx.EVT_PAINT(self, self.OnPaint)
        # wx.EVT_SIZE(self, self.OnSize)
        # wx.EVT_ERASE_BACKGROUND(self, self.OnErase)

        # OnSize called to make sure the buffer is initialized.
        # This might result in OnSize getting called twice on some
        # platforms at initialization, but little harm done.
        self.OnSize(None)
        self.paint_count = 0

    def Draw(self, dc):
        dc.SetBackground(wx.Brush("Grey"))
        dc.Clear()

        if self.design is None:
            return
        draw_data = self.design.draw_data
        current_stitch = self.design.current_stitch
        # Here's the actual drawing code.
        if current_stitch == -1:
            for drawElements in draw_data:
                dc.SetPen(wx.Pen(drawElements[0]))
                dc.DrawLineList(drawElements[1])
        else:
            count = 0
            count_range = 0
            for drawElements in draw_data:
                dc.SetPen(wx.Pen(drawElements[0]))
                count_range += len(drawElements[1])
                if current_stitch < count_range:
                    dif = current_stitch - count
                    segments = drawElements[1]
                    subsegs = segments[:dif]
                    dc.DrawLineList(subsegs)
                    break
                else:
                    dc.DrawLineList(drawElements[1])
                count = count_range

    def OnPaint(self, event):
        # All that is needed here is to draw the buffer to screen
        if USE_BUFFERED_DC:
            dc = wx.BufferedPaintDC(self, self._Buffer)
        else:
            dc = wx.PaintDC(self)
            dc.DrawBitmap(self._Buffer, 0, 0)

    def OnSize(self, event):
        # The Buffer init is done here, to make sure the buffer is always
        # the same size as the Window
        # Size  = self.GetClientSizeTuple()
        Size = self.ClientSize
        try:
            self.design.scale_draw_data(Size[0], Size[1])
        except AttributeError:
            pass
        # Make new offscreen bitmap: this bitmap will always have the
        # current drawing in it, so it can be used to save the image to
        # a file, or whatever.
        self._Buffer = wx.Bitmap(*Size)
        self.UpdateDrawing()

    def OnErase(self, event):
        pass

    def UpdateDrawing(self):
        """
        This would get called if the drawing needed to change, for whatever reason.

        The idea here is that the drawing is based on some data generated
        elsewhere in the system. If that data changes, the drawing needs to
        be updated.

        This code re-draws the buffer, then calls Update, which forces a paint event.
        """
        dc = wx.MemoryDC()
        dc.SelectObject(self._Buffer)
        self.Draw(dc)
        del dc  # need to get rid of the MemoryDC before Update() is called.
        self.Refresh()
        self.Update()

    def set_design(self, set_design):
        self.design = set_design
        self.UpdateDrawing()


# end of class EmbroideryView


class SimulatorView(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: SimulatorView.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((845, 605))
        self.stitch_slider = wx.Slider(self, wx.ID_ANY, 0, 0, 10)
        self.Bind(wx.EVT_SCROLL_CHANGED, self.on_slider_changed, self.stitch_slider)
        self.canvas = EmbroideryView(self, wx.ID_ANY)
        self.Bind(wx.EVT_CLOSE, self.on_close)

        # Menu Bar
        self.frame_menubar = wx.MenuBar()

        wxglade_tmp_menu = wx.Menu()
        menu_start = wxglade_tmp_menu.Append(wx.ID_ANY, "Start", "")
        self.Bind(wx.EVT_MENU, self.on_menu_start, menu_start)
        self.menu_start = menu_start
        menu_backwards = wxglade_tmp_menu.Append(wx.ID_ANY, "Backwards", "", wx.ITEM_CHECK)
        self.Bind(wx.EVT_MENU, self.on_menu_backwards, menu_backwards)
        menu_track = wxglade_tmp_menu.Append(wx.ID_ANY, "Track", "", wx.ITEM_CHECK)
        self.Bind(wx.EVT_MENU, self.on_menu_track, menu_track)

        self.frame_menubar.Append(wxglade_tmp_menu, "Options")
        self.SetMenuBar(self.frame_menubar)
        # Menu Bar end

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        self.design = None
        self.track = False
        self.forwards = True
        self.timer = None

    def on_slider_changed(self, event):
        self.design.current_stitch = event.GetPosition()
        self.canvas.UpdateDrawing()

    def on_menu_start(self, event):
        if not self.timer:
            self.timer = wx.PyTimer(self.update_tick)
            self.timer.Start(30)
            self.menu_start.SetItemLabel("Stop")
        else:
            self.timer.Stop()
            self.timer = None
            self.menu_start.SetItemLabel("Start")

    def on_menu_track(self, event):
        self.track = not self.track

    def on_menu_forwards(self, event):
        self.forwards = True

    def on_menu_backwards(self, event):
        self.forwards = not self.forwards

    def on_close(self, event):
        if self.timer is not None:
            self.timer.Stop()
        event.Skip()

    def update_tick(self):
        if self.forwards:
            self.design.increment_stitch()
        else:
            self.design.decrement_stitch()
        self.stitch_slider.SetValue(self.design.current_stitch)
        self.canvas.UpdateDrawing()

    def OnErase(self, event):
        pass

    def __set_properties(self):
        # begin wxGlade: SimulatorView.__set_properties
        self.SetTitle("Simulator")
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: SimulatorView.__do_layout
        sizer_3 = wx.BoxSizer(wx.VERTICAL)
        sizer_3.Add(self.stitch_slider, 0, wx.EXPAND, 0)
        sizer_3.Add(self.canvas, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_3)
        self.Layout()
        # end wxGlade

    def set_design(self, set_design):
        self.design = set_design.get_copy()
        self.canvas.set_design(self.design)
        self.stitch_slider.SetMax(self.design.max_stitch)
        self.stitch_slider.SetMin(0)


# end of class SimulatorView


class StitchEditor(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: StitchEditor.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((597, 627))

        self.grid = wx.grid.Grid(self, wx.ID_ANY, size=(1, 1))
        self.grid.Bind(wx.grid.EVT_GRID_LABEL_RIGHT_CLICK,
                       self.show_popup_menu_label)
        self.grid.Bind(wx.grid.EVT_GRID_CELL_RIGHT_CLICK,
                       self.show_popup_menu_cell)
        self.grid.Bind(wx.grid.EVT_GRID_CELL_CHANGED, self.on_grid_change)

        self.__set_properties()
        self.__do_layout()
        self.last_event = None
        self.command_menu = {}
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: StitchEditor.__set_properties
        self.SetTitle("Stitch Editor")
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: StitchEditor.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_1.Add(self.grid, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        self.Layout()
        # end wxGlade

    def on_grid_change(self, event):
        row = event.GetRow()
        col = event.GetCol()
        value = self.grid.GetCellValue(row, col)
        stitches = self.design.emb_pattern.stitches
        stitch = stitches[row]

        if col == -1:
            return
        elif col == 0:
            command_dict = get_command_dictionary()
            command = command_dict[value]
            stitch[2] = command
        elif col == 1:
            stitch[0] = float(value)
        elif col == 2:
            stitch[1] = float(value)

    def show_popup_menu_label(self, event):
        self.last_event = event
        menu = wx.Menu()

        menu_item = menu.Append(wx.ID_ANY, "Delete", "")
        self.Bind(wx.EVT_MENU, self.on_menu_delete, menu_item)

        menu_item = menu.Append(wx.ID_ANY, "Duplicate", "")
        self.Bind(wx.EVT_MENU, self.on_menu_duplicate, menu_item)

        self.PopupMenu(menu)
        menu.Destroy()

    def show_popup_menu_cell(self, event):
        self.last_event = event
        col = event.GetCol()
        if col != 0:
            return
        row = event.GetRow()
        stitches = self.design.emb_pattern.stitches
        stitch = stitches[row]

        self.last_event = event
        menu = wx.Menu()
        name_dict = get_common_name_dictionary()

        for the_key, the_value in name_dict.items():
            menu_item = menu.Append(the_key, the_value, the_value)
            self.Bind(wx.EVT_MENU, self.on_menu_cell_key, menu_item)
        self.PopupMenu(menu)
        menu.Destroy()

    def on_menu_cell_key(self, event):
        col = self.last_event.GetCol()
        row = self.last_event.GetRow()
        stitches = self.design.emb_pattern.stitches
        stitch = stitches[row]
        name_dict = get_common_name_dictionary()
        command = event.GetId()
        command_name = name_dict[command]
        stitch[2] = command
        self.grid.SetCellValue(row, col, command_name)

    def on_menu_delete(self, event):
        stitches = self.design.emb_pattern.stitches
        position = self.last_event.GetRow()
        del stitches[position]
        self.grid.DeleteRows(position)

    def on_menu_duplicate(self, event):
        stitches = self.design.emb_pattern.stitches
        position = self.last_event.GetRow()
        stitch = stitches[position]
        stitches.insert(position, stitch[:])
        self.grid.InsertRows(position)
        common_dict = get_common_name_dictionary()
        common_name = common_dict[stitch[2]]
        self.grid.SetCellValue(position, 0, common_name)
        self.grid.SetCellValue(position, 1, str(stitch[0]))
        self.grid.SetCellValue(position, 2, str(stitch[1]))

    def set_design(self, set_design):
        self.design = set_design
        max = len(self.design.emb_pattern.stitches)
        self.grid.CreateGrid(max, 3)
        self.grid.EnableDragColSize(0)
        self.grid.EnableDragRowSize(0)
        self.grid.EnableDragGridSize(0)
        self.grid.SetColLabelValue(0, "Command")
        self.grid.SetColLabelValue(1, "X")
        self.grid.SetColLabelValue(2, "Y")

        common_dict = get_common_name_dictionary()
        for i, stitch in enumerate(self.design.emb_pattern.stitches):
            common_name = common_dict[stitch[2]]
            self.grid.SetCellValue(i, 0, common_name)
            self.grid.SetCellValue(i, 1, str(stitch[0]))
            self.grid.SetCellValue(i, 2, str(stitch[1]))

    # end of class StitchEditor


class ColorEmbroidery(wx.Panel):
    def __init__(self, *args, **kwds):
        # begin wxGlade: ColorEmbroidery.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Panel.__init__(self, *args, **kwds)
        self.SetSize((400, 300))
        # self.tree_ctrl_1 = wx.TreeCtrl(self, wx.ID_ANY)
        # This was intended to display color information.
        self.canvas = EmbroideryView(self, wx.ID_ANY)

        self.__do_layout()
        self.design = None
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: ColorEmbroidery.__do_layout
        sizer_6 = wx.BoxSizer(wx.HORIZONTAL)
        # sizer_6.Add(self.tree_ctrl_1, 1, wx.EXPAND, 0)
        sizer_6.Add(self.canvas, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_6)
        self.Layout()
        # end wxGlade

    def set_design(self, set_design):
        self.design = set_design
        self.canvas.set_design(self.design)


# end of class ColorEmbroidery


class GuiMain(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: GuiMain.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((697, 552))
        self.main_notebook = wx.Notebook(self, wx.ID_ANY)
        self.Bind(wx.EVT_BOOKCTRL_PAGE_CHANGED, self.on_page_changed, self.main_notebook)

        # Menu Bar
        self.menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        menu_import = wxglade_tmp_menu.Append(wx.ID_ANY, "Import", "")
        self.Bind(wx.EVT_MENU, self.on_menu_import, menu_import)

        menu_export = wxglade_tmp_menu.Append(wx.ID_ANY, "Export", "")
        self.Bind(wx.EVT_MENU, self.on_menu_export, menu_export)
        self.menubar.Append(wxglade_tmp_menu, "File")
        wxglade_tmp_menu = wx.Menu()
        menu_stitch_edit = wxglade_tmp_menu.Append(wx.ID_ANY, "Stitch Edit", "")
        self.Bind(wx.EVT_MENU, self.on_menu_stitch_edit, menu_stitch_edit)

        self.menubar.Append(wxglade_tmp_menu, "Edit")
        wxglade_tmp_menu = wx.Menu()
        menu_simulate = wxglade_tmp_menu.Append(wx.ID_ANY, "Simulate", "")
        self.Bind(wx.EVT_MENU, self.on_menu_simulate, menu_simulate)
        self.menubar.Append(wxglade_tmp_menu, "View")
        self.SetMenuBar(self.menubar)
        # Menu Bar end

        self.__set_properties()
        # self.__do_layout()
        # end wxGlade
        self.designs = []
        self.focused_design = None

    def on_page_changed(self, event):
        page = self.main_notebook.CurrentPage
        if isinstance(page, ColorEmbroidery):
            self.focused_design = page.design

    def on_menu_stitch_edit(self, event):
        stitch_list = StitchEditor(None, wx.ID_ANY, "")
        stitch_list.set_design(self.focused_design)
        stitch_list.Show()

    def on_menu_import(self, event):
        files = ""
        for format in pyembroidery.supported_formats():
            try:
                if format["reader"] is not None:
                    files += "*." + format["extension"] + ";"
            except KeyError:
                pass

        with wx.FileDialog(self, "Open Embroidery", wildcard="Embroidery Files (" + files + ")",
                           style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return  # the user changed their mind
            pathname = fileDialog.GetPath()
            embdisplay = EmbroiderDisplay()
            embdisplay.load(str(pathname))
            self.add_display_embroidery(embdisplay)

    def on_menu_export(self, event):
        files = ""
        for format in pyembroidery.supported_formats():
            try:
                if format["writer"] is not None:
                    files += format["description"] + "(*." + format["extension"] + ")|*." + format[
                        "extension"] + "|"
            except KeyError:
                pass

        with wx.FileDialog(self, "Save Embroidery", wildcard=files[:-1],
                           style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT) as fileDialog:

            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return  # the user changed their mind

            # save the current contents in the file
            pathname = fileDialog.GetPath()
            pyembroidery.write(self.focused_design.emb_pattern, str(pathname))

    def on_menu_simulate(self, event):
        simulator = SimulatorView(None, wx.ID_ANY, "")
        simulator.set_design(self.focused_design)
        simulator.Show()

    def add_display_embroidery(self, embroidery):
        self.designs.append(embroidery)
        self.refresh_designs()

    def __set_properties(self):
        # begin wxGlade: GuiMain.__set_properties
        self.SetTitle("EmbroidepyEditor")
        # end wxGlade

    def refresh_designs(self):
        # empty_panel = wx.Panel(self.main_notebook, wx.ID_ANY)
        # self.main_notebook.AddPage(empty_panel, "Untitled")
        for design in self.designs:
            sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
            embrodery_panel = ColorEmbroidery(self.main_notebook, wx.ID_ANY)
            embrodery_panel.set_design(design)
            self.main_notebook.AddPage(embrodery_panel, design.name)
            sizer_5.Add(self.main_notebook, 1, wx.EXPAND, 0)
        self.Layout()
        page = self.main_notebook.CurrentPage
        if isinstance(page, ColorEmbroidery):
            self.focused_design = page.design
        # end wxGlade


# end of class GuiMain

class Embroidepy(wx.App):
    def OnInit(self):
        self.main_editor = GuiMain(None, wx.ID_ANY, "")
        self.SetTopWindow(self.main_editor)
        self.main_editor.Show()
        return True

    def add_display_embroidery(self, embroidery):
        self.main_editor.add_display_embroidery(embroidery)

    # end of class Embroidepy


if __name__ == "__main__":

    file = "BN000134_01.pes"
    if len(sys.argv) > 1:
        file = sys.argv[1]

    embdisplay = EmbroiderDisplay()
    embdisplay.load(file)

    embroiderpy = Embroidepy(0)
    embroiderpy.add_display_embroidery(embdisplay)
    embroiderpy.MainLoop()
